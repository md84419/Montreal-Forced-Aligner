--- venv/lib/python3.8/site-packages/montreal_forced_aligner/abc.py	2022-04-28 19:09:22.000000000 +0100
+++ pretrained.py	2022-04-29 10:45:13.783504100 +0100
@@ -1,10 +1,13 @@
 """Class definitions for aligning with pretrained acoustic models"""
 from __future__ import annotations
 
+from contextlib import redirect_stdout, redirect_stderr
 import csv
 import functools
+import io
 import multiprocessing as mp
 import os
+
 import time
 from typing import TYPE_CHECKING, Dict, List, Optional
 
@@ -61,8 +64,13 @@
     ):
         self.acoustic_model = AcousticModel(acoustic_model_path)
         kw = self.acoustic_model.parameters
-        print("KW", kw)
+        if not 'quiet' in kwargs:
+            self.logger.info( f"KW {kw}" )
+        else:
+            kw
         kw.update(kwargs)
+        if not 'quiet' in kwargs:
+            self.logger.info( f"KW {kw}" )
         super().__init__(**kw)
 
     @property
@@ -92,18 +100,19 @@
                 )
             self.acoustic_model.validate(self)
             self.acoustic_model.export_model(self.working_directory)
-            import logging
+            #import logging
 
-            logger = logging.getLogger(self.identifier)
-            self.acoustic_model.log_details(logger)
+            #logger = logging.getLogger(self.identifier)
+            
+            self.acoustic_model.log_details(self.logger)
 
         except Exception as e:
             if isinstance(e, KaldiProcessingError):
-                import logging
+                #import logging
 
-                logger = logging.getLogger(self.identifier)
-                log_kaldi_errors(e.error_logs, logger)
-                e.update_log_file(logger)
+                #logger = logging.getLogger(self.identifier)
+                log_kaldi_errors(e.error_logs, self.logger)
+                e.update_log_file(self.logger)
             raise
         self.initialized = True
         self.log_debug(f"Setup for alignment in {time.time() - begin} seconds")
@@ -355,8 +364,10 @@
             session.bulk_update_mappings(Utterance, update_mappings)
             session.query(Corpus).update({"alignment_evaluation_done": True})
             session.commit()
-        self.log_info(f"Average overlap score: {score_sum/score_count}")
-        self.log_info(f"Average phone error rate: {phone_edit_sum/phone_length_sum}")
+        if(score_count !=0 ):
+            self.log_info(f"Average overlap score: {score_sum/score_count}")
+        if(phone_length_sum !=0 ):
+            self.log_info(f"Average phone error rate: {phone_edit_sum/phone_length_sum}")
 
     def align_one_utterance(self, utterance: Utterance, session: Session):
         dictionary = utterance.speaker.dictionary
@@ -414,8 +425,14 @@
         )
         func = OnlineAlignmentFunction(args)
         word_intervals, phone_intervals, log_likelihood = func.run()
-        print(log_likelihood)
-        print(word_intervals, phone_intervals)
+        f = io.StringIO()
+        #with redirect_stdout(f):
+        if not 'quiet' in self.acoustic_model.parameters:
+            self.logger.info(log_likelihood)
+            self.logger.info(word_intervals, phone_intervals)
+        else:
+            log_likelihood
+            word_intervals, phone_intervals
         session.query(PhoneInterval).filter(PhoneInterval.utterance_id == utterance.id).delete()
         session.query(WordInterval).filter(WordInterval.utterance_id == utterance.id).delete()
         session.flush()
@@ -428,7 +445,14 @@
 
     def align(self) -> None:
         """Run the aligner"""
+        self.logger.debug("  about to setup")
+        start = time.time()
         self.setup()
+        end = time.time()
+        elapsed = int((end-start)*1000)
+        self.logger.debug( f"  setup took {elapsed} milliseconds" )
+        self.time = {}
+        self.time['setup'] = round(end-start,7)
         done_path = os.path.join(self.working_directory, "done")
         dirty_path = os.path.join(self.working_directory, "dirty")
         if os.path.exists(done_path):
@@ -437,12 +461,22 @@
         try:
             log_dir = os.path.join(self.working_directory, "log")
             os.makedirs(log_dir, exist_ok=True)
+            start = time.time()
             self.compile_train_graphs()
+            end = time.time()
+            elapsed = int((end-start)*1000)
+            self.logger.debug( f"  compile_train_graphs took {elapsed} milliseconds" )
+            self.time['compile_train_graphs'] = round(end-start,7)
 
             self.log_info("Performing first-pass alignment...")
             self.speaker_independent = True
+            start = time.time()
             self.align_utterances()
-            self.compile_information()
+            end = time.time()
+            elapsed = int((end-start)*1000)
+            self.logger.debug( f"  first pass align_utterances took {elapsed} milliseconds" )
+            self.time['first pass align_utterances'] = round(end-start,7)
+            #self.compile_information()
             if self.uses_speaker_adaptation:
                 if self.alignment_model_path.endswith(".mdl"):
                     if os.path.exists(self.alignment_model_path.replace(".mdl", ".alimdl")):
@@ -453,19 +487,24 @@
 
                 self.speaker_independent = False
                 assert self.alignment_model_path.endswith(".mdl")
-                self.log_info("Performing second-pass alignment...")
+                self.logger.debug("Performing second-pass alignment...")
+                start = time.time()
                 self.align_utterances()
+                end = time.time()
+                elapsed = int((end-start)*1000)
+                self.logger.debug( f"  second pass align_utterances took {elapsed} milliseconds" )
+                self.time['second pass align_utterances'] = round(end-start,7)
 
-                self.compile_information()
+                #self.compile_information()
         except Exception as e:
             with open(dirty_path, "w"):
                 pass
             if isinstance(e, KaldiProcessingError):
-                import logging
+                #import logging
 
-                logger = logging.getLogger(self.identifier)
-                log_kaldi_errors(e.error_logs, logger)
-                e.update_log_file(logger)
+                #logger = logging.getLogger(self.identifier)
+                log_kaldi_errors(e.error_logs, self.logger)
+                e.update_log_file(self.logger)
             raise
         with open(done_path, "w"):
             pass
